## クライアントサーバアーキテクチャ
webサーバはHTTPを使って通信するすべてのクライアントのホストとなる。
![client-and-server](https://github.com/user-attachments/assets/c58d4683-5292-4633-87f6-d30b9ff69812)

スケーラビリティ大量のユーザーが同時にアクセスしても、サーバがダウンすることなくスムーズに情報を提供できるようにするための工夫  
  
![scalability](https://github.com/user-attachments/assets/afd81a4d-733c-4c17-9fe0-1a7bea41dffc)

## webサーバの目的
クライアントが要求する様々なリソースを保管し、管理し、提供する役割を果たす。(HTML,CSS,Js,画像,動画,PDF,JSON,ZIPなど)  

### なぜリソースはサーバ側で保管するのか??
- **動的コンテンツ**  
リソースを動的に生成し、リクエストのパラメータやデータベースの状態によってそれを変化させることが可能だから。
ユーザーから提供された情報を元に個々のユーザーに対して特化したHTMLファイルを生成することができる。(login五のダッシュボードページなど)
サイトのスクレイピング -> PDFレポートを生成する
MP4ファイル: ユーザーが投稿した動画 + バックエンドで行われたAI変換の結果に基づいて新たに動画を生成(動画共有サービスやAIを利用した動画編集サービスなど)  

- **スケーラビリティ**  
大量のストレージスペースが必要になるため。(ユーザーのデバイスのストレージには限界がある)  

- **リソースの共有**  
特定のユーザーやグループがwebサーバ上の特定のリソースにアクセスして内容を変更できる。  

- **アップデートの一元化**  
ファイルの最新のアップデートやパッチを保持。更新されたファイルをWebサーバにアップロードし、即座に配布できる。  
  
パッチとは: ソフトウェアやオペレーティングシステムのバグを修正したり、新たな機能を追加したり、既存の機能を改善したりするためのソフトウェアのアップデートのこと。  

- **セキュリティ**  
サーバへのアクセスを制限し、サーバレベルでセキュリティ対策を実施することで機密情報や占有リソースを安全に保護できる。   

### ビジネスロジックの大部分がサーバ上で行われる理由
- **パフォーマンス**  
クライアントがサービスの計算を処理するために必要なCPUパワー、ストレージ、帯域幅を常に保証できない。  
重いタスクや複雑なデータを処理するためには、Webサーバが垂直にスケーリングや並列計算などのインフラとスケーリング技術を活用することが求められる。  

- **集中型のデータ処理**  
データの処理や操作を一つの場所で行うことでサーバから提供されるサービスやデータの処理結果は均一になる  

- **データセキュリティ**  
重要なロジックをサーバ上に保持することで、アクセス制御、認証メカニズムの実装、機密情報の暗号化といったセキュリティ対策を施すことができる。  
クライアント側のロジックはセキュリティの脆弱性や改ざんのリスクが存在。  
サーバレベルではデータの完全性を確保するためにデータの検証などより多くの保護層を実行できる。  


- **知的財産の保護**
アクセス制限するためのにコアロジックはサーバ上に保管される。これによりリバースエンジニアリングや不正使用のリスクが最小限に抑えられる。  
サーバはどのようにプログラムが実行されるかは公開していないため、サーバは完全なブラックボックスとなり企業の知的財産を保護する役割を果たす。　　

### 利便性について

- **迅速な開発**  
ビジネスロジックを分離することで各チームは自分たちの専門分野に集中することができる。
  - バックエンドチーム: ビジネスロジック
  - フロントエンドチーム: 対象プラットフォームのクライアントコードに焦点を当てる

- **構築済みインフラ**  
プロトコル(HTTP/HTTPS)の標準化、主要なプログラミング言語はHTTPリクエストを送信するためのライブラリ等、インターネット技術を直接サポート、データ圧縮技術や暗号化などの組み込み最適化とセキュリティ、世界中の開発者やユーザーが情報を共有できる大規模なコミュニティエコシステムなどが存在。  
HTTPプロトコル以外の通信方法が必要とされる状況: HTTPプロトコルでは実現できないほどパフォーマンスが重要である一方でリソースの制限がある場合はUDPやオーバーヘッドの少ないTCP接続で特定の最適化が施される。
  

- **クロスプラットフォーム**  
クライアントは標準化されたインターフェースを通じてサーバサイドのロジックにアクセスできる  

- **アプリケーションサーバ統合**  
開発者がサービスにアクセスする最も便利な方法: webAPI  

## 静的サイトのWebサーバ
情報が定期的に更新されることは少なく、一度ウェブサーバにアップロードされるとその内容は基本的に固定される。  
コンテンツは直接ウェブサーバ上に保存され、ユーザーのリクエストに基づいてそのままの形で配信される。

![web-server-file-pass](https://github.com/user-attachments/assets/6fd5118a-0a5c-4b8b-8067-e05b00ec60e8)

![static-public-server](https://github.com/user-attachments/assets/a9c29fcc-0d83-4317-af9c-5976fdeddbb8)

## 動的サイトのWebサーバ
コンテンツはサーバ側でリアルタイムに生成される。
ユーザーからのHTTPリクエストをウェブアプリケーションに渡し、ウェブアプリケーションがリクエストに応じてページの内容を動的に生成する。DBから情報を取得したりユーザー入力を処理したりすることができる。  
メディアファイルなどの静的なリソースはウェブサーバに保存されることが一般的だが、それらのリソースは動的に生成されたHTMLページの一部として配信される。  
ユーザーが入力したデータやデータベースから取得したデータなど動的に変更される情報はウェブアプリケーションによって処理される。

- **Wiki型Webページ(動的サイト)**
ウェブ上のコンテンツの作成と編集を多数のユーザーが行うことを可能にしている。

1. HTTPリクエストを受け取る
2. ウェブアプリケーションのエントリーポイントに渡す
3. リクエストを解析し処理する (PHPの場合 -> `index.php`)
4. URLを特定の関数にマッピングし、その関数を呼び出す(ルーティング)
5. リクエストデータ(dataやcookieを含むリクエストのボディ)を解析する。(HTTPリクエストのボディを読み取り、適切な形式に変換するプロセスを指す)
6. リクエストの処理が終わると、生成したリソースをクライアントに返す(ページ生成に必要なデータを保存するため、DBに接続するのが一般的)

![dynamic-server-1](https://github.com/user-attachments/assets/19558a08-271b-49d6-84e8-55219a7fd91c)

![3-tier](https://github.com/user-attachments/assets/55ed85d0-18d8-40ae-b419-09d8ebd8e581)

## EコマースのWebサーバ
各ユーザーが個別のデータを持つため複雑なプロセスを伴うため、ユーザー認証とセキュリティが重要な要素となる
- 購入履歴
- 注文状況
- 請求明細
- お気に入りリスト

ウェブAPIを通じてサードパーティのサービスに接続することがあるため、すべての支払い処理インフラを持つ支払いゲートウェイが必要になる。  
サプライチェーン管理、財務・会計、データ分析といった機能を提供する外部のERPソフトウェアとの連携も必要となる。  
ユーザーがGoogle, Facebook, Twitterなどのサービスを通じて登録やログインを行う。

![e-commerce-web-server](https://github.com/user-attachments/assets/fb111c6e-47a3-4739-8897-e10438e9c37e)

## SNSのWebサーバ
数億人のユーザーに対応する必要がある。  
複数のターゲットプラットフォーム向けにクライアントアプリケーションを提供。Webブラウザ、iOS、Android、デスクトップ、スマートデバイスなどが含まれ全てが同じサーバに接続する。  
SNSでは、ライブデータの同期をサポートするwebソケットのような双方向データストリームを用いたり、ライブビデオやグループチャットのような追加機能を提供したりする。  

### ウェブサーバのスケーリング

- **垂直スケーリング**: ハードウェアのアップグレード
  コストがかかり上限がある。  
- **水平スケーリング**: サーバノードを増やす
  実現方法の一つ: ウェブサーバをリバースプロキシに変換する。

- **リバースプロキシの役割**:
受け取ったリクエストをバックエンドのサーバノードの一つに転送し、そこでリクエストを処理する。
リバースプロキシはバックエンドサーバのリストを保持し、ラウンドロビンアルゴリズムを適用して負荷を均等に分散する。(ロードバランシング)
![sns-web-server](https://github.com/user-attachments/assets/edd93b12-0fa1-4c03-b309-68b99c3c1183)

静的ファイルリソースについては、CDN(ユーザーに近い場所に静的ファイルをキャッシュするサーバのこと)を使用することで、バックエンドの負荷をさらに減らすことができる。

### データベースのスケーリング
全てのサーバは同じデータにアクセスする必要があり、またサーバの負荷を軽減するためにデータベースにも水平スケーリングを適用する必要がある。  
SNSでは、書き込みより読み込みの方がずっと多いことが一般的。読み取りを多数のデータベースサーバに分散する必要があり、そのためにはマスタースレーブレプリケーションと呼ばれる技術が適用される。  
書き込みが行われるデータベースがマスターデータベースとなり、そのデータが複製されてスレーブデータベースに伝播する。  
![sns-master-slave](https://github.com/user-attachments/assets/633469d4-50bb-4a5d-a0a9-a9bd7c0d405b)

![sns-web-server-architecture](https://github.com/user-attachments/assets/c0b2c2db-4051-4a08-9038-e7973d449ae8)

## HyperText Transfer Protocol
HTTPはインターネット上での通信のために最も一般的に使用されるプロトコル  

![http](https://github.com/user-attachments/assets/dbd3d646-4d1d-4fe2-9136-b6059c2aad65)

### HTTPの歴史
- **初期のHTTP(0.9)**
TCP接続後、"GET"というメソッドに続くパスをリクエストに含む形式が採用されていた。例: `GET/page.html`
サーバはリクエストに応じてHTMLファイルの内容をASCII文字のバイトストリームとして返すことを求められた。

- **HTTP/1.0**: 多くの新たな構文が導入
- **HTTP/1.1**: 構文に微細な調整が加えられた
このプロトコルは、クライアントやサーバなどの多くのアプリケーションが使うアプリケーション層で標準化されており、安全で信頼性の高いパケットの送受信を可能にするために、`UDP`ではなく`TCP/IP`を使用

### TCP
- **ヘッダー**: パケットが正しく送られるための情報(どこから来てどこへ送信されるかなど)を持つ
- **ペイロード**: ユーザーが実際に送りたいデータ(Webサイトの情報など)を持つ

![header-payload](https://github.com/user-attachments/assets/8b65bb3b-a9c0-43fa-b800-bf89cb7ed296)

## HTTPリクエスト・レスポンス
**ブラウザがサーバとの間で通信を行う手順**

- **Step1**
URLがブラウザのアドレスバーに入力される。
  - どのように通信するか(HTTP/HTTPS)
  - どのサイトに行くか(ドメイン名)
  - そのサイトのどの部分(ファイルのパス)
  - 特殊な条件(クエリパラメータ)

![url-browser](https://github.com/user-attachments/assets/5ced120b-89ab-45e3-8c2b-8d2975a9f083)

- **Step2**
ブラウザは取得したサーバのIPアドレスとポート番号を利用して、TCP/IP接続を開始する  

- **Step3**
ブラウザとサーバはハンドシェイクを行い、接続が確立する。その後、ブラウザはHTTPリクエストメッセージを生成し、その中にmethod, scheme, path, cookies, accepted-languageなどのパラメータヘッダを埋め込み、サーバに送信する。  

![three-way-handshake](https://github.com/user-attachments/assets/81ce7d76-6422-4fce-89ae-0f99a634428f)

- **Step4**
サーバは受け取ったHTTPリクエストを解析し、提供されたパス、メソッドタイプ、ボディなどのHTTPデータを用いてリクエストを処理する。その後、HTTPレスポンスをブラウザに返し、リクエストを満たす。

- **Step5**
ブラウザはサーバからのHTTPレスポンスを受け取り、レスポンスヘッダとボディの情報を使用してリソース(Webページ)をレンダリングする。

- **Step6**
Webページに含まれるHTML, CSS, Jsなどのウェブファイルがさらにリソースを必要とする場合、追加のHTTPリクエストをサーバに送信する。  

![http-request-procedure](https://github.com/user-attachments/assets/7a572d41-95d3-4878-bdd5-c97c0fa1b794)

- HTTP: Port80
- HTTPS: Port443

![http-port](https://github.com/user-attachments/assets/0454abf5-854c-459d-b625-733e5bb21078)

## HTTPリクエスト
クライアントがサーバに対して情報の取得や送信を依頼するための通信メッセージ。

![http-request-header-get](https://github.com/user-attachments/assets/7c2a3314-630e-4672-aa1a-c4037f489986)

- **リクエスト行**
HTTPメソッド、指定されたパスまたはアクセスしたいリソース、使用されるHTTPプロトコルのバージョンを含むリクエストの最初の部分。
例: `GET/index.html HTTP/1.1` -> GETメソッドを使ってファイル`index.html` にアクセスし、ブラウザがHTTPバージョン1.1をサポートしていることを意味する。

- **リクエストヘッダー**
リクエストやクライアントに関する指示や情報など、追加のメタデータをサーバに提供
  - Host: リクエストされたリソースのインターネットホストとポート番号を特定する
  - Accept-Language: クライアントがレスポンスに使用する言語をサーバに知らせる
  - Content-Type: リクエストボディのメディアタイプ(フォーマット)を指定する
  - Authorization: クライアントの身元を確認するための認証情報を伝える
  - Connection: 現在のトランザクションが完了した後もネットワーク接続を開いたままにするかどうかを指定する

- **リクエストボディ**
サーバに送信したい実際のデータを含む。POSTリクエストの際によく使われる。
POSTリクエストは、サーバに対して新たな情報を送信するためのHTTPメソッドで、データの作成や更新を要求する際に使用できる。このPOSTリクエストの際に送信されるデータが、リクエストボディに格納される。

![http-request-header-post](https://github.com/user-attachments/assets/3f33adb5-f8bf-425f-88a9-627e1dbb5c9c)

ウェブアプリケーションはデータベースとの間で情報を読み取り、作成、更新、削除する。(CRUD)
CRUD操作をウェブアプリケーションから行うためには、HTTPリクエストというプロトコルが使用される。

#### リクエストの形式一覧
![http-request-crud](https://github.com/user-attachments/assets/745b9747-5c48-40ba-aa45-dec77976cf30)

- GET: Read操作。リソースからデータを要求する。フィルタリング用のパラメータをURLで渡すこともできる。
- POST: Create操作。リソースを更新するためにデータをサーバに送信する。正確なアクションは`URL`と`リクエストボディ`によって決定される。
- PUT: Update操作。新しいリソースを作成するか、既存のリソースを置き換える。
- DELETE: Delete操作。指定したリソースを削除する。

![http-request-rest-api](https://github.com/user-attachments/assets/3e2276a8-bde0-472c-9e48-22a6b965be1f)


## HTTPレスポンス
サーバがクライアントのHTTPリクエストに応じて送り出すメッセージ

![http-response](https://github.com/user-attachments/assets/1d386a6b-e2ee-4f25-a20d-6d16cd8f55a9)

- **ステータス行**
レスポンスの開始部分で、使用されるHTTPプロトコルのバージョン、ステータスコードという数値、そのステータスコードを説明するテキストフレーズが含まれている。
  - 1xx (情報): 100 Continueや 101 Switching Protocolsのように、途中経過を示すレスポンス
  - 2xx (成功): 200 OK や 201 Created のように、リクエストが成功したことを表す
  - 3xx (リダイレクト): 301 Moved Permanently や 302 Found のように、追加のアクションが必要なことを示す
  - 4xx (クライアントエラー): 400 Bad Request や 404 Not Found のように、クライアントのリクエストに問題があることを伝える
  - 5xx (サーバエラー): 500 Internal Server Error や 503 Service Unavailable など、サーバ側に問題があることを示す
[HTTPステータスコードの完全なリストと説明](https://www.rfc-editor.org/rfc/rfc9110#name-status-codes)


- **レスポンスヘッダー**
レスポンスやサーバに関する追加情報を提供。

  - `Cache-Control`: キャッシュの動作を制御する。値には`public`, `private`, `no-cache`などがある。
  - `Content-Disposition`: クライアントがレスポンスの内容をダウンロードする際のファイル名を指定する
  - `Content-Encoding`: レスポンスボディで使用されているエンコーディング方式を示す。`gzip`, `deflate`, `br`(Brotli) などのエンコーディング方式がある。
  - `Content-Type`: レスポンスのメディアタイプを指定する。例えば、`text/html`はHTMLドキュメント、`application/json`はJSON形式のデータ、`image/jpeg`はJPEG形式の画像データを示す。
  - `Expires`: レスポンスがキャッシュとしてどれだけの期間新鮮なものとして保持されるかを示す。指定された日時を過ぎると、キャッシュは古いとみなされる。
  - `Last-Modified`: レスポンス内容が最後に変更された日時を示す。この値は、サーバとクライアントがコンテンツの新鮮さを判断するために使われる。
  - `Location`: クライアントを別のURLにリダイレクトするために使用される。主に`3xx`のHTTPステータスコードと共に使用される。
  - `Server`: リクエストを処理するサーバが使用するソフトウェアとそのバージョンを示す。
  - `Set-Cookie`: クライアントのブラウザにクッキーを設定する。サーバがクライアントに特有の情報を保持し、その後のリクエストでその情報を再利用するためのもの。

[リクエストヘッダーの詳細](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)  

- **レスポンスボディ**
サーバがクライアントのリクエストに応答する形で返す具体的な内容。ボディの内容の形式は、ヘッダ内の`Content-Type`フィールドによって定義される。Webブラウザは、これらの内容をバイトとして解釈し、さまざまなメディアタイプを処理することができる。

## HTTP/1.1

Web通信の中心となるプロトコルであり、その仕様は1997年に初めて発表された。  

### Head-of-line blocking(HOL blocking)と呼ばれる問題
各リクエスト・レスポンスはTCP接続を必要としていた。そのため、すべてのデータが受信されてから次のデータを要求する `ブロック` が発生した。  
例えば、あるドメインから10個の異なるリソースをリクエストする場合、それぞれのリクエストが完全に満たされるまで待たなければいけないという状況だった。  
各リソースが個別のリクエストを必要とするため結果新たなTCP接続の確立に時間がかかってしまう。対策としては、10個の異なるTCP接続を作成し、それぞれを通じてリソースをリクエストするという対策が取られてきた。  

![http-hol-blocking](https://github.com/user-attachments/assets/5b7266ba-b294-43bf-88a9-8fda2f114faa)

この手法では、各リクエストは並行して実行されるがそれぞれのTCP接続がハンドシェイクを必要とし、サーバが同時に扱うことのできる接続数には限界があるため、この方法にはオーバーヘッドが生じる。  
HTTP/1.1 では、HTTP メッセージは TCP パケットとして一度に全体が送信されます。すべてのデータが送信されるとレスポンスが完成し、クライアント側はこれを content-length フィールドや TCP 接続の終了を通じて確認します。  

## HTTP/2(1)

### HTTP/1.1の問題点と解決
- `HOL blocking`はWebページのロード時間を大幅に増加させ、ユーザーエクスペリエンスを損なう可能性がある。(大量データや複数リソースを要求する現代では特に)  
- `HOL blocking`を解決するために、HTTP/2ではマルチプレクシング、リソースの優先付け、ヘッダ圧縮、サーバプッシュなどが導入された。  

### バイナリプロトコルとフレーム
- バイナリプロトコル: データをバイナリ形式で送受信する通信規約。これによりデータの送受信効率が向上
- フレーム: データ送信の単位のことで、大きなデータを小さなフレームに分割して送信することで、通信効率とレスポンスの速度を向上させることができる。

フレーム全体のデータを小さな単位である「フレーム」に分割し、それぞれが個別に送信される。フレーム単位での送信が終了すると、全体のデータの送信が終了したと認識される。  
TCPの送信処理と似ているが、違いはこの挙動が「トランスポート層」ではなく、HTTPが動作する「アプリケーション層」で行われている点。

![http2](https://github.com/user-attachments/assets/97e539fb-7717-4a0c-b37d-f366c5e71ff0)

### 開発者ビューのネットワークタブでは見ることができないネットワークレベルのログを確認できるツール
- net-export:ユーザーがブラウザで行ったネットワーク活動（ウェブサイトへのアクセス、データのダウンロードなど）を JSON 形式（一種のデータ形式）で記録できる。この機能を使うと、ネットワーク通信の詳細を確認したり、問題の原因を探ることができる。
- netlog-viewer: ウェブベースのツールで、https://netlog-viewer.appspot.com からアクセスできる。`//net-export` で生成したログを視覚的に解析することができ、特に、HTTP/2 の「フレーム」単位の通信を視覚的に確認することができ、各フレームがどのように送受信されているかを理解するのに役立ちます。

[Capture Network log](chrome://net-export/)  
[chrome-net-export-log.json](https://netlog-viewer.appspot.com/#import)  

- マルチプレキシング: 複数のリクエストとレスポンスが単一のTCP接続を共有できる機能。つまり、一つのTCP接続上で複数のリクエストとレスポンスを並行して処理できるようになった。
- リソースの優先付け: 単一の接続上で複数のリクエストとレスポンスが行われるが、リソースが等しく重要ではないため、HTTP/2では各ストリームに優先順位をつけることが可能になった。-> 重要なリソースが先に送信され、Webページのパフォーマンスが向上。
優先順位は「PRIORITY」フレームを使って設定。クライアントはこのフレームを使って、どのリクエストが他のリクエストよりも重要であるかをサーバに伝えることができる。また、優先順位は動的に変更することも可能なので、これによりクライアントはリソースのロード順序を最適化できる。

例えば、Webページのレンダリングに重要なCSSやJsを最初にダウンロードし、その後で画像などのその他のリソースをダウンロードするなど制御が可能。  

![resource-priority](https://github.com/user-attachments/assets/1837d49e-6a66-44a6-adcc-827c8ab1af12)

- ヘッダ圧縮: HTTP/2ではデータはバイナリ形式で送信されるようになった。バイナリ形式はテキスト形式と比べて効率的にデータを圧縮できるため、ネットワーク上でのデータ転送が高速化する。
- サーバプッシュ: サーバ側からクライアント側に対して、クライアントがまだ明示的に要求していないリソースを予測的に送信する機能を指す。
例: WebブラウザがあるWebページを要求 -> このHTMLページは、画像やCSS、Jsなどその他の追加的なリソースを必要とする。サーバプッシュでは、サーバがクライアントに、クライアントがまだ要求していないデータ(特定のWebページで使用される画像やCSSなど)を予測的に送信することを可能とする。(一方向性のため、サーバがクライアントに対して予測的にデータを送信するもの)

![server-push](https://github.com/user-attachments/assets/67258a89-c715-4d19-a42f-7c29c446a9fc)

## HTTP/3

### HTTP/2の問題点
特にTCPを基盤とすることによる制約が指摘。信頼性の高いデータ転送を提供するが、一部の状況ではパフォーマンス上の課題がある。  
- HOL blocking
  HTTP/2はTCP上で動作するが、TCP自体はHOL blocking問題を完全に解決していない。
  HTTP/2が一つのTCP接続で複数のリクエストとレスポンスを扱えるようにしたため、HTTPレベルのHOL blockingは緩和されたが、TCPレベルでは依然として存在する。
  パケットが順序通りに到着しないと、後続のパケットがブロックされるという問題。

- TCP接続の設定とウォームアップ
  TCP接続を確立するためにはハンドシェイクが必要であり、それには時間がかかる。また、TCPには輻輳制御というメカニズムを使用してネットワークを混雑を管理するが、これにより接続速度が最初は遅く、徐々に速度が上がる「ウォームアップ」が必要になる。

### 解決
従来のTCPを使用せず、QUICプロトコルという新しいプロトコルを使用。QUICはUDPをベースに作られているが一部の特性はTCPに近い  
  
TCPは信頼性の高い接続を保証し、データの順序付けや再送信などを行う。一方、UDPはこれらの機能を提供しない代わりに、より高速なデータ転送が可能。  
QUICはこのUDPの拘束性を保ちつつ、TCPのような信頼性の高さも持つように設計されている。(データの再送信や順序付けなどの機能を実装している)

![http3](https://github.com/user-attachments/assets/2e470c18-f113-49d3-a182-63e236ed6c93)  

QUIC は接続確立時間の短縮、輻輳制御（ネットワークの混雑を抑えるための機能）の改善、IP 間の切り替え（例えば、スマートフォンがWi-Fiからモバイルデータへ切り替えるときなどの切り替え）をスムーズに行うなど、TCP 以上の利点を提供します。











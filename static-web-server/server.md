## クライアントサーバアーキテクチャ
webサーバはHTTPを使って通信するすべてのクライアントのホストとなる。
![client-and-server](https://github.com/user-attachments/assets/c58d4683-5292-4633-87f6-d30b9ff69812)

スケーラビリティ大量のユーザーが同時にアクセスしても、サーバがダウンすることなくスムーズに情報を提供できるようにするための工夫  
  
![scalability](https://github.com/user-attachments/assets/afd81a4d-733c-4c17-9fe0-1a7bea41dffc)

## webサーバの目的
クライアントが要求する様々なリソースを保管し、管理し、提供する役割を果たす。(HTML,CSS,Js,画像,動画,PDF,JSON,ZIPなど)  

### なぜリソースはサーバ側で保管するのか??
- **動的コンテンツ**  
リソースを動的に生成し、リクエストのパラメータやデータベースの状態によってそれを変化させることが可能だから。
ユーザーから提供された情報を元に個々のユーザーに対して特化したHTMLファイルを生成することができる。(login五のダッシュボードページなど)
サイトのスクレイピング -> PDFレポートを生成する
MP4ファイル: ユーザーが投稿した動画 + バックエンドで行われたAI変換の結果に基づいて新たに動画を生成(動画共有サービスやAIを利用した動画編集サービスなど)  

- **スケーラビリティ**  
大量のストレージスペースが必要になるため。(ユーザーのデバイスのストレージには限界がある)  

- **リソースの共有**  
特定のユーザーやグループがwebサーバ上の特定のリソースにアクセスして内容を変更できる。  

- **アップデートの一元化**  
ファイルの最新のアップデートやパッチを保持。更新されたファイルをWebサーバにアップロードし、即座に配布できる。  
  
パッチとは: ソフトウェアやオペレーティングシステムのバグを修正したり、新たな機能を追加したり、既存の機能を改善したりするためのソフトウェアのアップデートのこと。  

- **セキュリティ**  
サーバへのアクセスを制限し、サーバレベルでセキュリティ対策を実施することで機密情報や占有リソースを安全に保護できる。   

### ビジネスロジックの大部分がサーバ上で行われる理由
- **パフォーマンス**  
クライアントがサービスの計算を処理するために必要なCPUパワー、ストレージ、帯域幅を常に保証できない。  
重いタスクや複雑なデータを処理するためには、Webサーバが垂直にスケーリングや並列計算などのインフラとスケーリング技術を活用することが求められる。  

- **集中型のデータ処理**  
データの処理や操作を一つの場所で行うことでサーバから提供されるサービスやデータの処理結果は均一になる  

- **データセキュリティ**  
重要なロジックをサーバ上に保持することで、アクセス制御、認証メカニズムの実装、機密情報の暗号化といったセキュリティ対策を施すことができる。  
クライアント側のロジックはセキュリティの脆弱性や改ざんのリスクが存在。  
サーバレベルではデータの完全性を確保するためにデータの検証などより多くの保護層を実行できる。  


- **知的財産の保護**
アクセス制限するためのにコアロジックはサーバ上に保管される。これによりリバースエンジニアリングや不正使用のリスクが最小限に抑えられる。  
サーバはどのようにプログラムが実行されるかは公開していないため、サーバは完全なブラックボックスとなり企業の知的財産を保護する役割を果たす。　　

### 利便性について

- **迅速な開発**  
ビジネスロジックを分離することで各チームは自分たちの専門分野に集中することができる。
  - バックエンドチーム: ビジネスロジック
  - フロントエンドチーム: 対象プラットフォームのクライアントコードに焦点を当てる

- **構築済みインフラ**  
プロトコル(HTTP/HTTPS)の標準化、主要なプログラミング言語はHTTPリクエストを送信するためのライブラリ等、インターネット技術を直接サポート、データ圧縮技術や暗号化などの組み込み最適化とセキュリティ、世界中の開発者やユーザーが情報を共有できる大規模なコミュニティエコシステムなどが存在。  
HTTPプロトコル以外の通信方法が必要とされる状況: HTTPプロトコルでは実現できないほどパフォーマンスが重要である一方でリソースの制限がある場合はUDPやオーバーヘッドの少ないTCP接続で特定の最適化が施される。
  

- **クロスプラットフォーム**  
クライアントは標準化されたインターフェースを通じてサーバサイドのロジックにアクセスできる  

- **アプリケーションサーバ統合**  
開発者がサービスにアクセスする最も便利な方法: webAPI  

## 静的サイトのWebサーバ
情報が定期的に更新されることは少なく、一度ウェブサーバにアップロードされるとその内容は基本的に固定される。  
コンテンツは直接ウェブサーバ上に保存され、ユーザーのリクエストに基づいてそのままの形で配信される。

![web-server-file-pass](https://github.com/user-attachments/assets/6fd5118a-0a5c-4b8b-8067-e05b00ec60e8)

![static-public-server](https://github.com/user-attachments/assets/a9c29fcc-0d83-4317-af9c-5976fdeddbb8)

## 動的サイトのWebサーバ
コンテンツはサーバ側でリアルタイムに生成される。
ユーザーからのHTTPリクエストをウェブアプリケーションに渡し、ウェブアプリケーションがリクエストに応じてページの内容を動的に生成する。DBから情報を取得したりユーザー入力を処理したりすることができる。  
メディアファイルなどの静的なリソースはウェブサーバに保存されることが一般的だが、それらのリソースは動的に生成されたHTMLページの一部として配信される。  
ユーザーが入力したデータやデータベースから取得したデータなど動的に変更される情報はウェブアプリケーションによって処理される。

- **Wiki型Webページ(動的サイト)**
ウェブ上のコンテンツの作成と編集を多数のユーザーが行うことを可能にしている。

1. HTTPリクエストを受け取る
2. ウェブアプリケーションのエントリーポイントに渡す
3. リクエストを解析し処理する (PHPの場合 -> `index.php`)
4. URLを特定の関数にマッピングし、その関数を呼び出す(ルーティング)
5. リクエストデータ(dataやcookieを含むリクエストのボディ)を解析する。(HTTPリクエストのボディを読み取り、適切な形式に変換するプロセスを指す)
6. リクエストの処理が終わると、生成したリソースをクライアントに返す(ページ生成に必要なデータを保存するため、DBに接続するのが一般的)

![dynamic-server-1](https://github.com/user-attachments/assets/19558a08-271b-49d6-84e8-55219a7fd91c)

![3-tier](https://github.com/user-attachments/assets/55ed85d0-18d8-40ae-b419-09d8ebd8e581)

## EコマースのWebサーバ
各ユーザーが個別のデータを持つため複雑なプロセスを伴うため、ユーザー認証とセキュリティが重要な要素となる
- 購入履歴
- 注文状況
- 請求明細
- お気に入りリスト

ウェブAPIを通じてサードパーティのサービスに接続することがあるため、すべての支払い処理インフラを持つ支払いゲートウェイが必要になる。  
サプライチェーン管理、財務・会計、データ分析といった機能を提供する外部のERPソフトウェアとの連携も必要となる。  
ユーザーがGoogle, Facebook, Twitterなどのサービスを通じて登録やログインを行う。

![e-commerce-web-server](https://github.com/user-attachments/assets/fb111c6e-47a3-4739-8897-e10438e9c37e)

## SNSのWebサーバ
数億人のユーザーに対応する必要がある。  
複数のターゲットプラットフォーム向けにクライアントアプリケーションを提供。Webブラウザ、iOS、Android、デスクトップ、スマートデバイスなどが含まれ全てが同じサーバに接続する。  
SNSでは、ライブデータの同期をサポートするwebソケットのような双方向データストリームを用いたり、ライブビデオやグループチャットのような追加機能を提供したりする。  

### ウェブサーバのスケーリング

- **垂直スケーリング**: ハードウェアのアップグレード
  コストがかかり上限がある。  
- **水平スケーリング**: サーバノードを増やす
  実現方法の一つ: ウェブサーバをリバースプロキシに変換する。

- **リバースプロキシの役割**:
受け取ったリクエストをバックエンドのサーバノードの一つに転送し、そこでリクエストを処理する。
リバースプロキシはバックエンドサーバのリストを保持し、ラウンドロビンアルゴリズムを適用して負荷を均等に分散する。(ロードバランシング)
![sns-web-server](https://github.com/user-attachments/assets/edd93b12-0fa1-4c03-b309-68b99c3c1183)

静的ファイルリソースについては、CDN(ユーザーに近い場所に静的ファイルをキャッシュするサーバのこと)を使用することで、バックエンドの負荷をさらに減らすことができる。

### データベースのスケーリング
全てのサーバは同じデータにアクセスする必要があり、またサーバの負荷を軽減するためにデータベースにも水平スケーリングを適用する必要がある。  
SNSでは、書き込みより読み込みの方がずっと多いことが一般的。読み取りを多数のデータベースサーバに分散する必要があり、そのためにはマスタースレーブレプリケーションと呼ばれる技術が適用される。  
書き込みが行われるデータベースがマスターデータベースとなり、そのデータが複製されてスレーブデータベースに伝播する。  
![sns-master-slave](https://github.com/user-attachments/assets/633469d4-50bb-4a5d-a0a9-a9bd7c0d405b)

![sns-web-server-architecture](https://github.com/user-attachments/assets/c0b2c2db-4051-4a08-9038-e7973d449ae8)

## HyperText Transfer Protocol
HTTPはインターネット上での通信のために最も一般的に使用されるプロトコル  

![http](https://github.com/user-attachments/assets/dbd3d646-4d1d-4fe2-9136-b6059c2aad65)

### HTTPの歴史
- **初期のHTTP(0.9)**
TCP接続後、"GET"というメソッドに続くパスをリクエストに含む形式が採用されていた。例: `GET/page.html`
サーバはリクエストに応じてHTMLファイルの内容をASCII文字のバイトストリームとして返すことを求められた。

- **HTTP/1.0**: 多くの新たな構文が導入
- **HTTP/1.1**: 構文に微細な調整が加えられた
このプロトコルは、クライアントやサーバなどの多くのアプリケーションが使うアプリケーション層で標準化されており、安全で信頼性の高いパケットの送受信を可能にするために、`UDP`ではなく`TCP/IP`を使用

### TCP
- **ヘッダー**: パケットが正しく送られるための情報(どこから来てどこへ送信されるかなど)を持つ
- **ペイロード**: ユーザーが実際に送りたいデータ(Webサイトの情報など)を持つ

![header-payload](https://github.com/user-attachments/assets/8b65bb3b-a9c0-43fa-b800-bf89cb7ed296)

## HTTPリクエスト・レスポンス
**ブラウザがサーバとの間で通信を行う手順**

- **Step1**
URLがブラウザのアドレスバーに入力される。
  - どのように通信するか(HTTP/HTTPS)
  - どのサイトに行くか(ドメイン名)
  - そのサイトのどの部分(ファイルのパス)
  - 特殊な条件(クエリパラメータ)

![url-browser](https://github.com/user-attachments/assets/5ced120b-89ab-45e3-8c2b-8d2975a9f083)

- **Step2**
ブラウザは取得したサーバのIPアドレスとポート番号を利用して、TCP/IP接続を開始する  

- **Step3**
ブラウザとサーバはハンドシェイクを行い、接続が確立する。その後、ブラウザはHTTPリクエストメッセージを生成し、その中にmethod, scheme, path, cookies, accepted-languageなどのパラメータヘッダを埋め込み、サーバに送信する。  

![three-way-handshake](https://github.com/user-attachments/assets/81ce7d76-6422-4fce-89ae-0f99a634428f)

- **Step4**
サーバは受け取ったHTTPリクエストを解析し、提供されたパス、メソッドタイプ、ボディなどのHTTPデータを用いてリクエストを処理する。その後、HTTPレスポンスをブラウザに返し、リクエストを満たす。

- **Step5**
ブラウザはサーバからのHTTPレスポンスを受け取り、レスポンスヘッダとボディの情報を使用してリソース(Webページ)をレンダリングする。

- **Step6**
Webページに含まれるHTML, CSS, Jsなどのウェブファイルがさらにリソースを必要とする場合、追加のHTTPリクエストをサーバに送信する。  

![http-request-procedure](https://github.com/user-attachments/assets/7a572d41-95d3-4878-bdd5-c97c0fa1b794)

- HTTP: Port80
- HTTPS: Port443

![http-port](https://github.com/user-attachments/assets/0454abf5-854c-459d-b625-733e5bb21078)


## 抽象構造体

アイデアを抽象化し、状況に応じて適用するための構造体。

- 具体例

- 決まった順序の要素
- 特定位置の要素の取得: get(position)
- 特定位置に要素を追加: addAt(position, element)
- 特定位置に配列全体を追加: addAt(position, array)
- 特定位置の要素を削除: removeAt(position)
- i 番目から j 番目までの要素の削除: removeAt()
- i 番目から j 番目までの部分リストの取得: subList()

## 課題

ここからは、具体的な実装に移りましょう。動的配列を用いる IntegerArrayList と、連結リストを用いる IntegerLinkedList の二つの具象クラスを実装してください。IntegerArrayList を実装する際には、内部的には ArrayList のような動的配列を用いて、実装してください。

addAt(int index, int[] elements) をオーバーライドして、特定のデータ構造を追加できるようにすることも可能です。例えば、addAt(int index, IntegerLinkedList elements) のようにします。

また、それぞれのデータ構造の時間計算量を考えてみましょう。例えば、動的配列を使用した場合と、連結リストを使用した場合で、要素を取得する際の時間計算量にどのような違いがあるでしょうか？さらに、100 万個の要素を持つ部分リストを特定の位置に追加したり（addAll()）、特定の位置から削除する場合はどうでしょうか？

データ構造の選択、連結リストや動的配列の作成にあたっては、これらの時間計算量について考慮する必要があります。多くの場合、最も汎用的なバージョン（ここでは AbstractListInteger）を宣言し、具体的な要求に応じて具象クラスをインスタンス化します。

さらに、ポリモーフィズムを活用して、具体的な実装（連結リストや動的配列）に関わらず AbstractListInteger を取得する関数を作成することも可能です。たとえば、add(AbstractListInteger list) といったメソッドを作成すると、連結リストであれ動的配列であれ、同じ AbstractListInteger の契約を満たしていれば、同じ値にアクセスできます。

## OS(Operating System) の概要

**ハードウェアの管理:** OS がハードウェアを適切に管理し、ユーザーにそれらを意識させずにインターフェースとしての違いを抽象化している。
そのためハードウェアのリソースを意識せずに効率的にアプリケーションを扱える。

![what-is-os (1)](https://github.com/user-attachments/assets/9761cf1c-a978-46e2-b694-f8ae8bce0f32)

**ほとんどのアプリケーション:** OS の提供する API を使用して動作。これにより、プログラムが OS を直接対話するための道筋を作る。

## OS の役割

1. リソース管理としての役割
   - プロセス管理
   - メモリ管理
   - ファイルシステム
   - ストレージ管理
   - 入出力システム管理

![os-resource-management](https://github.com/user-attachments/assets/55a7ebaa-d7b3-4215-a73e-692c2f4f57a1)

   
2. 抽象化されたインターフェースとしての役割
   ユーザーがコンピュータの構造を意識せずに操作できるようにする役割を果たす。CPU やストレージ、モニター、マウスなどのハードウェアの違いを考慮せずにさまざまなプログラムが動作している。これは OS がコンピュータの構造を抽象化し、インターフェースとして機能するために実現されている。

![os-interface (1)](https://github.com/user-attachments/assets/67f65523-569f-423a-9d1b-d052d993df90)


## ノイマン型アーキテクチャ

コンピュータの構造の一つのモデル化: 今日のコンピュータのほとんどはノイマン型アーキテクチャを採用している。

![neumann-architecture (1)](https://github.com/user-attachments/assets/0d108339-942c-4655-a31a-ee4a00ec1493)


### ノイマン型アーキテクチャの構成要素

- **演算装置:** 数値や論理計算を行う部分。
- **制御装置:** コンピュータの操作をコントロールする中心的な部分。
- **主記憶装置(メインメモリ):** 命令やデータを一時的に保存する部分。
- **入力装置:** キーボードやマウスなどからの情報を受け取る部分。
- **出力装置:** 画面やプリンタなどに情報を出力する部分。

- プログラム内蔵方式: 命令をあらかじめメインメモリに格納しておく方法。
- 逐次制御方式: 1 つずつ CPU が命令を取り出して実行すること。

メインメモリは通常、RAM(ランダムアクセスメモリ)が使用される。

## CPU (中央演算装置: Central processing unit, CPU)

### 構成

- 制御装置: デコーダと呼ばれ、命令を解読し、他の周辺機器を制御する。
- 演算装置: 実際の計算を行う部分

### レジスタ

コンピュータの CPU 内に存在する小さな記憶領域で、非常に高速にアクセスできる部分。計算処理に必要なデータを一時的に保存するために使用される。

- メインメモリは大量のデータを保存する場所なので、それぞれのデータは特定のアドレスに格納される。
- レジスタは特定の操作や制御のために使用される小さな記憶領域で、それぞれのレジスタには特定の役割がある。

![cpu-overview (1)](https://github.com/user-attachments/assets/70c56cc7-aceb-4ed5-8022-0f5eadd612b6)


- **命令レジスタ**: 実行中の命令を格納するレジスタ。今 CPU が何をしているのかを示す情報を保持。
- **命令アドレスレジスタ(プログラムカウンタ)**: 次に実行する命令のアドレスが格納されているレジスタ。
- **汎用レジスタ**: 役割が割り当てられていない汎用的に利用できるレジスタ。

### 命令サイクル(コンピュータの CPU がプログラムの命令をどのように処理するかを表すサイクル)

命令サイクルの完了を待つのではなく、他のステップが同時に実行されたり、パイプライン化されたりすることで、効率的な実行が確保される。

1. **Fetch**

- **目的**: CPU が次に実行すべき命令をメモリから取得するプロセス。
- **具体的な操作**: プログラムカウンタ(PC)に格納されたアドレスを使用して、命令メモリから対応する命令を取得。(取得された命令は命令レジスタに格納される。)
- **プログラムカウンタの更新**: 命令がフェッチされた後、プログラムカウンタは次の命令のアドレスを指すように更新される。

2. **Decode**

- **目的**: フェッチされた命令を解析し、何をすべきかを決定するプロセス。
- **具体的な操作**: 命令レジスタに格納された命令は、その命令のオペコード(操作コード)を解析して分解される。CPU がどのような操作を行うべきかを指示。
- **オペランドの取得**: 必要に応じて追加の情報(オペランド)がレジスタまたはメモリから取得されることがある。(命令が実行すべき具体的なデータやアドレスを指す。)

3. **Execute**

- **目的**: デコードされた命令を実際に実行するプロセス。
- **具体的な動作**: 演算装置などの CPU のコンポーネントが動作し、命令に対応する具体的な計算や操作が実行される。(算術処理、論理処理、データの移動、比較など)
- **結果**: 実行の結果は、メモリアクセスやライトバック(命令を実行した計算結果を保持する別のレジスタ)に渡される場合がある。また、結果が条件分岐命令である場合、プログラムカウンタが更新され、新しい実行パスが選択されることがある。

![instruction-cicle](https://github.com/user-attachments/assets/bde86dc1-1a79-4e46-89d5-51c7b3af62f8)

### キャッシュ
CPU の計算サイクルは、メインメモリのアクセス速度よりもはるかに速いため、メインメモリの速度がボトルネックになる。
そのため、CPU の近くに位置するより高速なキャッシュが、主記憶との速度差を補うために CPU 内部に配置される。キャッシュはメインメモリよりも高速にアクセスできるメモリで、CPU が最もよく使用するデータや命令を一時的に保存する。
これにより、CPU がメインメモリにアクセスする必要が減少し、全体のシステム性能が向上する。

![os-cache](https://github.com/user-attachments/assets/56d9d230-3314-4322-bd9d-45d9fab6e18d)

- **L1 キャッシュ**: CPU コアごとに存在し、非常に高速だが容量が小さい。データキャッシュと命令キャッシュに分かれている。
- **L2 キャッシュ**: L1 キャッシュより大きくやや遅いが、メインメモリより遥かに速い。
- **L3 キャッシュ**: CPU 全体で共有されるキャッシュで L1 や L2 よりもさらに大きい容量を持つが、アクセス速度は遅くなる。(メインメモリに比べると速いので全体の性能向上に寄与する。)

## メインメモリ
- **主記憶装置(main memory)**: コンピュータシステムにおいて、CPUが直接アクセスできる記憶装置でRAMはこの中に含まれる。
- **RAM**: コンピュータのメインメモリとして使用される揮発性 (電力が供給されないと保持できない性質なので、CPをシャットダウンするとRAM内のデータは全て失われる) のメモリ。

![os-main-memory](https://github.com/user-attachments/assets/cb8cbd02-9fb3-4afa-8157-bc6d50a57a28)

### RAMの特徴
データの位置に関係なく、同じ時間でデータにアクセスができる。
- **DRAM (Dynamic Random Access Memory)**: メインメモリに使用されるタイプで、動作は遅いが消費電力が小さく生産コストが低い。
- **SRAM (Static Random Access Memory)**: CPUのキャッシュメモリに使用されるタイプで、動作が非常に速いが消費電力が大きい。

## ストレージ
データを永続的に保管する場所。データを保持するために`補助記憶装置 (auxiliary memory units)`が使用される。

![os-storage](https://github.com/user-attachments/assets/e2e9370e-06d3-4c58-816f-d0ae0b69ef81)

### 特徴
アクセス速度を犠牲にして、大量のデータを低コストで永続的に保存できる。

### 比較表

| 特徴       | HDD            | 磁気テープ       | SSD            |
|------------|----------------|------------------|----------------|
| 速度       | 中速           | 低速             | 高速           |
| 容量       | 大容量         | 非常に大容量     | 容量あたり高価 |
| 耐久性     | 衝撃に弱い     | 長期保存に強い   | 衝撃に強い     |
| 構造       | 機械的部品あり | 磁気テープ       | フラッシュメモリ |
| 主な用途   | PC、サーバー   | アーカイブ、バックアップ | PC、モバイルデバイス |

- **ROM (read only memory)**: コンピュータ内でデータを保存するためのメモリの一種で、一度書き込まれたデータは消去できない。

![ssd](https://github.com/user-attachments/assets/5dcbeb9b-a67c-4115-89bf-c717fc2894a3)

## I/0デバイス
- 入力: ユーザーからのユーザーからの指示やデータをコンピュータに送る事
- 出力: コンピュータからユーザーへ情報を送ること

### 入力デバイス
ユーザーからの情報をコンピュータに送信する役割を果たす
- キーボード
- マウス
- タッチパッド
- スキャナ

### 出力デバイス
コンピュータからユーザーへ情報を提供する
- モニタ
- プリンタ
- スピーカー

- **デバイスドライバ**: OSだけで直接管理することは難しいため、デバイスドライバというソフトウェアを使用。
特定のデバイスが正しく動作するための指示を出す。デバイスとコンピュータの間で適切に通信を行うことを目的とする。

![io-device-driver](https://github.com/user-attachments/assets/84fe9a59-539e-490e-879c-fd182a444bfb)

- **バス(bus)**: CPUやメインメモリ、デバイスをつなげる役割を果たす信号線。
  
![os-bus](https://github.com/user-attachments/assets/30e44d90-8fea-4382-b769-2d43c156336b)

## OSの要素
- **役割**: ハードウェアの物理的な違いを隠蔽し、コンピュータの内部構造を抽象化すること。これにより、異なるハードウェア上でも同じアプリケーションを実行できる。
例: HDDとSSDなどの補助記憶装置があるのだが、これらの違いはOSによって隠蔽され、ユーザーから見るとCドライブやDドライブといった形で認識されるようになる。

![os-element](https://github.com/user-attachments/assets/bf7d9d44-bf82-4c7a-94fc-a630f4dc55a7)

## ブートローダとカーネル
- **ブートローダ(boot loader)**: コンピュータの電源を入れた後にOSを起動されるプログラムのこと。
1. 電源を入れた後、マザーボードのROM内に格納されたBIOS(UEFI)と呼ばれるプログラムが実行され、各デバイスが初期化される。
2. その後、接続されているデバイスの中からブートローダがメインメモリに読み込まれ、ブートローダの実行によってOSが起動される。

![motherboard](https://github.com/user-attachments/assets/10b10695-caed-4418-95b4-875f00e9db95)
![boot-loader (1)](https://github.com/user-attachments/assets/a09cc31d-f3da-4959-9684-273564891aa5)

- **カーネル(kernel)**: OSの中核をなすプログラムで、CPUの管理(プロセス管理・スケジューリング等)、メインメモリの管理、I/Oデバイス管理、ファイルシステム管理など。
ユーザーが直接カーネルを触るとデータの不正アクセスやプログラム間の干渉などの問題が起こるため、システムコールを通して操作する。

![monolithic-micro](https://github.com/user-attachments/assets/46b572d1-5a56-409f-9964-953c1bc6e825)

## システムコールとシェル
- **システムコール(system call)**: OSの核となる部分であるカーネルの機能を呼び出す特別な命令。ファイルの操作、プロセスの管理など、コンピュータの基本的な操作を行うために使用される。

![system-call-interface](https://github.com/user-attachments/assets/ef7d2545-cbc2-4fe1-a138-268cfcc9dea6)

[システムコールの詳細](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/syscalls.2.html)

システムコールは高級プログラミング言語から直接呼び出すことはできないため、アセンブリコード(使用するハードウェアに依存する)と呼ばれる低レベルのプログラミング言語を使用する必要がある。

- **アセンブリ言語**: コンピュータのプロセッサが直接解釈できる機械語に非常に近い低レベルのプログラミング言語。高級言語に比べて直接的で詳細な記述が必要なため、理解することは一般的に難しい。

OSがラッパー関数を提供しているため、開発者はハードウェア依存のアセンブリコードの違いを認識せずに、システムコールを利用することができる。
Linuxではこれらのシステムコールは標準Cライブラリとして提供されているため、用意にシステムコールを使用することができる。

![system-call-flow](https://github.com/user-attachments/assets/98cebe82-77ee-4eeb-bbae-93d8f631724d)

- **カーネルモードとユーザーモード**
カーネルは、コンピュータの中心で、メインメモリの管理やCPUのタスクのスケジューリングなど、システムの基本的な操作を行う。この操作が不正に行われれば、セキュリティ上の問題が発生する可能性があるため、カーネルモードとユーザーモードの2つのモードに分けている。

### ユーザーモード
一般のユーザーが使うソフトウェア、アプリケーション、ミドルウェアなどの実行のためのモード。重要なメモリ領域やI/Oデバイスへの直接アクセスが制限されている。
安全に処理できるかを確認した後、必要に応じてカーネルモードに切り替え特権的な操作を行うことができる。

### カーネルモード
OSが直接使用するモードで、特権モードとも呼ばれている。メモリ管理、デバイスドライバの制御、セキュリティの実装など、システム全体の基本的な操作が可能。
アクセス制限がなく、メモリやI/Oデバイスに対する操作が完全に自由で、CPUの全命令も実行することができる。

![kernel-user-mode](https://github.com/user-attachments/assets/623cc929-4116-4530-9c1e-4e31a4e8aa22)

- **シェル**: OSの機能にアクセスするためのインターフェースで、コマンドラインから操作するためのソフトウェアツール。
通常のユーザーがOSの中核部分であるカーネルに直接アクセスすることは危険。そのためシェルが仲介役を果たす。
シェルの背後にはシステムコールという重要な概念が存在する。

![shell](https://github.com/user-attachments/assets/8e1fc627-06fd-4726-b7d2-29796c39509e)

例: `mkdir foo` -> `mkdir()`というシステムコールを使用し、指定された場所に`foo`というディレクトリを作成する。(ユーザー自身がシステムコールを直接扱う必要はない。)

カーネルを取り囲むような外殻の役割を果たすことからシェルという名前に。

## プロセス
- **プロセス(process)**: プログラムのインスタンスのようなもので、実行中のプログラムのことを言う。プロセスが始まると、メモリが割り当てられて、CPUやメモリ、ファイル、入出力デバイスなどのリソースが使われる。
- **OSのプロセス**: コンピュータの基本的な操作を制御するためのプロセス。ファイルシステムの管理、メモリの管理、デバイス制御など。
- **ユーザーインターフェースのプロセス**: ウィンドウシステムやマウス、キーボードの操作を管理するプロセス。
- **アプリケーションプロセス**: 一般的なユーザーが使用するソフトウェア。Webブラウザ、テキストエディタ、ゲーム、画像編集ソフトウェア
- **システムサービスプロセス**: OSが提供する機能を実行するプロセスで、ファイルのバックアップ、アップデートのチェック、ネットワークの管理など。
- **コマンドラインプロセス**: コマンドラインインターフェースから実行されるプロセスで、シェルスクリプトやバッチファイルなどの自動化されたタスクを処理。
- **デーモンプロセス**: UNIX系システムで用いられる、バックグラウンドで常に動作しているプロセス。メールサーバー、Webサーバなど。

Linuxでは、`top`コマンドによって実行中のプロセスとリソースの使用率などの一覧が表示できる。

- PID: プロセスに与えられる固有の番号ID。
- PR: プロセスの優先度。
- S: プロセスの現在の状態。プロセスには、複数の状態がある。
  - D: 入出力の完了待ち状態で、この状態のプロセスは停止できない。
  - R: 実行中、または実行可能な状態のプロセス。CPUを使用している、または使用する予定の状態
  - S: スリープ状態で、中断が可能な待機状態のプロセス。
  - T: 一時停止状態のプロセス。
  - Z: ゾンビ状態のプロセス。処理は終わっているが、親プロセスによる最終チェックがまだ終わっていないプロセス。

![process](https://github.com/user-attachments/assets/4c4b3e1e-fc39-4e17-9842-df904f427a97)

## マルチプロセスと割り込み

CPUの空き時間をなるべく減らして、CPUを効率よく利用することが重要。
- **マルチプロセス(マルチタスク)**: 一般に１つのCPUに対して、1つのプロセスしか実行することができない。しかし、複数のプロセスを高速で切り替えることにより、人の認識からは同時に移動しているように見せることができる。

![multi-task](https://github.com/user-attachments/assets/743bea8e-a2a0-46e9-902e-69b647a1094c)

- **プロセススケジューラ**: 適切にプロセスを処理するために使用される。どのプロセスをどれくらいの時間で、どのCPUで実行させるかという管理。
- **割り込み**: マルチタスクの中で、特定のイベントが発生した場合にそのプロセスを一時中断して特別な処理を行う役割を果たす。
  - ハードウェア割り込み: 外部デバイスやハードウェアからの信号によって引き起こされる。キーボードの入力やマウスのクリック、プリンターのエラーなど。
  - ソフトウェア割り込み: ソフトウェアの動作に基づいて発生。プログラムのエラー、例外処理、タイマー割り込みなど
- **割り込みベクタ**: 割り込みの要因ごとに固有の番号やアドレスを持つ。CPUが割り込みを受けると、割り込みベクタを参照して、割り込み処理プログラムの正確な場所へジャンプする。

### 割り込み処理の流れ
1. 割り込み信号受信: CPUが割り込み信号を受信する。
2. 現在の状態保存: 実行中のプロセスの状態(レジスタなど)を保存する。
3. 割り込み処理プログラム実行: 割り込みベクタに従い、割り込み処理プログラムを実行する。
4. 状態復元: 割り込み前のプロセスの状態を復元する。
5. プロセス再開: 中断していたプロセスの処理を再開。

## プロセスツリー

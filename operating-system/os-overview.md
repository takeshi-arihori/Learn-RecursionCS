## OS(Operating System) の概要

**ハードウェアの管理:** OS がハードウェアを適切に管理し、ユーザーにそれらを意識させずにインターフェースとしての違いを抽象化している。
そのためハードウェアのリソースを意識せずに効率的にアプリケーションを扱える。

![what-is-os (1)](https://github.com/user-attachments/assets/9761cf1c-a978-46e2-b694-f8ae8bce0f32)

**ほとんどのアプリケーション:** OS の提供する API を使用して動作。これにより、プログラムが OS を直接対話するための道筋を作る。

## OS の役割

1. リソース管理としての役割
   - プロセス管理
   - メモリ管理
   - ファイルシステム
   - ストレージ管理
   - 入出力システム管理

![os-resource-management](https://github.com/user-attachments/assets/55a7ebaa-d7b3-4215-a73e-692c2f4f57a1)

   
2. 抽象化されたインターフェースとしての役割
   ユーザーがコンピュータの構造を意識せずに操作できるようにする役割を果たす。CPU やストレージ、モニター、マウスなどのハードウェアの違いを考慮せずにさまざまなプログラムが動作している。これは OS がコンピュータの構造を抽象化し、インターフェースとして機能するために実現されている。

![os-interface (1)](https://github.com/user-attachments/assets/67f65523-569f-423a-9d1b-d052d993df90)


## ノイマン型アーキテクチャ

コンピュータの構造の一つのモデル化: 今日のコンピュータのほとんどはノイマン型アーキテクチャを採用している。

![neumann-architecture (1)](https://github.com/user-attachments/assets/0d108339-942c-4655-a31a-ee4a00ec1493)


### ノイマン型アーキテクチャの構成要素

- **演算装置:** 数値や論理計算を行う部分。
- **制御装置:** コンピュータの操作をコントロールする中心的な部分。
- **主記憶装置(メインメモリ):** 命令やデータを一時的に保存する部分。
- **入力装置:** キーボードやマウスなどからの情報を受け取る部分。
- **出力装置:** 画面やプリンタなどに情報を出力する部分。

- プログラム内蔵方式: 命令をあらかじめメインメモリに格納しておく方法。
- 逐次制御方式: 1 つずつ CPU が命令を取り出して実行すること。

メインメモリは通常、RAM(ランダムアクセスメモリ)が使用される。

## CPU (中央演算装置: Central processing unit, CPU)

### 構成

- 制御装置: デコーダと呼ばれ、命令を解読し、他の周辺機器を制御する。
- 演算装置: 実際の計算を行う部分

### レジスタ

コンピュータの CPU 内に存在する小さな記憶領域で、非常に高速にアクセスできる部分。計算処理に必要なデータを一時的に保存するために使用される。

- メインメモリは大量のデータを保存する場所なので、それぞれのデータは特定のアドレスに格納される。
- レジスタは特定の操作や制御のために使用される小さな記憶領域で、それぞれのレジスタには特定の役割がある。

![cpu-overview (1)](https://github.com/user-attachments/assets/70c56cc7-aceb-4ed5-8022-0f5eadd612b6)


- **命令レジスタ**: 実行中の命令を格納するレジスタ。今 CPU が何をしているのかを示す情報を保持。
- **命令アドレスレジスタ(プログラムカウンタ)**: 次に実行する命令のアドレスが格納されているレジスタ。
- **汎用レジスタ**: 役割が割り当てられていない汎用的に利用できるレジスタ。

### 命令サイクル(コンピュータの CPU がプログラムの命令をどのように処理するかを表すサイクル)

命令サイクルの完了を待つのではなく、他のステップが同時に実行されたり、パイプライン化されたりすることで、効率的な実行が確保される。

1. **Fetch**

- **目的**: CPU が次に実行すべき命令をメモリから取得するプロセス。
- **具体的な操作**: プログラムカウンタ(PC)に格納されたアドレスを使用して、命令メモリから対応する命令を取得。(取得された命令は命令レジスタに格納される。)
- **プログラムカウンタの更新**: 命令がフェッチされた後、プログラムカウンタは次の命令のアドレスを指すように更新される。

2. **Decode**

- **目的**: フェッチされた命令を解析し、何をすべきかを決定するプロセス。
- **具体的な操作**: 命令レジスタに格納された命令は、その命令のオペコード(操作コード)を解析して分解される。CPU がどのような操作を行うべきかを指示。
- **オペランドの取得**: 必要に応じて追加の情報(オペランド)がレジスタまたはメモリから取得されることがある。(命令が実行すべき具体的なデータやアドレスを指す。)

3. **Execute**

- **目的**: デコードされた命令を実際に実行するプロセス。
- **具体的な動作**: 演算装置などの CPU のコンポーネントが動作し、命令に対応する具体的な計算や操作が実行される。(算術処理、論理処理、データの移動、比較など)
- **結果**: 実行の結果は、メモリアクセスやライトバック(命令を実行した計算結果を保持する別のレジスタ)に渡される場合がある。また、結果が条件分岐命令である場合、プログラムカウンタが更新され、新しい実行パスが選択されることがある。

![instruction-cicle](https://github.com/user-attachments/assets/bde86dc1-1a79-4e46-89d5-51c7b3af62f8)

### キャッシュ
CPU の計算サイクルは、メインメモリのアクセス速度よりもはるかに速いため、メインメモリの速度がボトルネックになる。
そのため、CPU の近くに位置するより高速なキャッシュが、主記憶との速度差を補うために CPU 内部に配置される。キャッシュはメインメモリよりも高速にアクセスできるメモリで、CPU が最もよく使用するデータや命令を一時的に保存する。
これにより、CPU がメインメモリにアクセスする必要が減少し、全体のシステム性能が向上する。

![os-cache](https://github.com/user-attachments/assets/56d9d230-3314-4322-bd9d-45d9fab6e18d)

- **L1 キャッシュ**: CPU コアごとに存在し、非常に高速だが容量が小さい。データキャッシュと命令キャッシュに分かれている。
- **L2 キャッシュ**: L1 キャッシュより大きくやや遅いが、メインメモリより遥かに速い。
- **L3 キャッシュ**: CPU 全体で共有されるキャッシュで L1 や L2 よりもさらに大きい容量を持つが、アクセス速度は遅くなる。(メインメモリに比べると速いので全体の性能向上に寄与する。)

## メインメモリ
- **主記憶装置(main memory)**: コンピュータシステムにおいて、CPUが直接アクセスできる記憶装置でRAMはこの中に含まれる。
- **RAM**: コンピュータのメインメモリとして使用される揮発性 (電力が供給されないと保持できない性質なので、CPをシャットダウンするとRAM内のデータは全て失われる) のメモリ。

![os-main-memory](https://github.com/user-attachments/assets/cb8cbd02-9fb3-4afa-8157-bc6d50a57a28)

### RAMの特徴
データの位置に関係なく、同じ時間でデータにアクセスができる。
- **DRAM (Dynamic Random Access Memory)**: メインメモリに使用されるタイプで、動作は遅いが消費電力が小さく生産コストが低い。
- **SRAM (Static Random Access Memory)**: CPUのキャッシュメモリに使用されるタイプで、動作が非常に速いが消費電力が大きい。

## ストレージ
データを永続的に保管する場所。データを保持するために`補助記憶装置 (auxiliary memory units)`が使用される。

![os-storage](https://github.com/user-attachments/assets/e2e9370e-06d3-4c58-816f-d0ae0b69ef81)

### 特徴
アクセス速度を犠牲にして、大量のデータを低コストで永続的に保存できる。

### 比較表

| 特徴       | HDD            | 磁気テープ       | SSD            |
|------------|----------------|------------------|----------------|
| 速度       | 中速           | 低速             | 高速           |
| 容量       | 大容量         | 非常に大容量     | 容量あたり高価 |
| 耐久性     | 衝撃に弱い     | 長期保存に強い   | 衝撃に強い     |
| 構造       | 機械的部品あり | 磁気テープ       | フラッシュメモリ |
| 主な用途   | PC、サーバー   | アーカイブ、バックアップ | PC、モバイルデバイス |

- **ROM (read only memory)**: コンピュータ内でデータを保存するためのメモリの一種で、一度書き込まれたデータは消去できない。

![ssd](https://github.com/user-attachments/assets/5dcbeb9b-a67c-4115-89bf-c717fc2894a3)

## I/0デバイス
- 入力: ユーザーからのユーザーからの指示やデータをコンピュータに送る事
- 出力: コンピュータからユーザーへ情報を送ること

### 入力デバイス
ユーザーからの情報をコンピュータに送信する役割を果たす
- キーボード
- マウス
- タッチパッド
- スキャナ

### 出力デバイス
コンピュータからユーザーへ情報を提供する
- モニタ
- プリンタ
- スピーカー

- **デバイスドライバ**: OSだけで直接管理することは難しいため、デバイスドライバというソフトウェアを使用。
特定のデバイスが正しく動作するための指示を出す。デバイスとコンピュータの間で適切に通信を行うことを目的とする。

![io-device-driver](https://github.com/user-attachments/assets/84fe9a59-539e-490e-879c-fd182a444bfb)

- **バス(bus)**: CPUやメインメモリ、デバイスをつなげる役割を果たす信号線。
  
![os-bus](https://github.com/user-attachments/assets/30e44d90-8fea-4382-b769-2d43c156336b)

## OSの要素
- **役割**: ハードウェアの物理的な違いを隠蔽し、コンピュータの内部構造を抽象化すること。これにより、異なるハードウェア上でも同じアプリケーションを実行できる。
例: HDDとSSDなどの補助記憶装置があるのだが、これらの違いはOSによって隠蔽され、ユーザーから見るとCドライブやDドライブといった形で認識されるようになる。

![os-element](https://github.com/user-attachments/assets/bf7d9d44-bf82-4c7a-94fc-a630f4dc55a7)

## ブートローダとカーネル
- **ブートローダ(boot loader)**: コンピュータの電源を入れた後にOSを起動されるプログラムのこと。
1. 電源を入れた後、マザーボードのROM内に格納されたBIOS(UEFI)と呼ばれるプログラムが実行され、各デバイスが初期化される。
2. その後、接続されているデバイスの中からブートローダがメインメモリに読み込まれ、ブートローダの実行によってOSが起動される。

![motherboard](https://github.com/user-attachments/assets/10b10695-caed-4418-95b4-875f00e9db95)
![boot-loader (1)](https://github.com/user-attachments/assets/a09cc31d-f3da-4959-9684-273564891aa5)

- **カーネル(kernel)**: OSの中核をなすプログラムで、CPUの管理(プロセス管理・スケジューリング等)、メインメモリの管理、I/Oデバイス管理、ファイルシステム管理など。
ユーザーが直接カーネルを触るとデータの不正アクセスやプログラム間の干渉などの問題が起こるため、システムコールを通して操作する。

![monolithic-micro](https://github.com/user-attachments/assets/46b572d1-5a56-409f-9964-953c1bc6e825)

## システムコールとシェル
- **システムコール(system call)**: OSの核となる部分であるカーネルの機能を呼び出す特別な命令。ファイルの操作、プロセスの管理など、コンピュータの基本的な操作を行うために使用される。

![system-call-interface](https://github.com/user-attachments/assets/ef7d2545-cbc2-4fe1-a138-268cfcc9dea6)

[システムコールの詳細](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/syscalls.2.html)

システムコールは高級プログラミング言語から直接呼び出すことはできないため、アセンブリコード(使用するハードウェアに依存する)と呼ばれる低レベルのプログラミング言語を使用する必要がある。

- **アセンブリ言語**: コンピュータのプロセッサが直接解釈できる機械語に非常に近い低レベルのプログラミング言語。高級言語に比べて直接的で詳細な記述が必要なため、理解することは一般的に難しい。

OSがラッパー関数を提供しているため、開発者はハードウェア依存のアセンブリコードの違いを認識せずに、システムコールを利用することができる。
Linuxではこれらのシステムコールは標準Cライブラリとして提供されているため、用意にシステムコールを使用することができる。

![system-call-flow](https://github.com/user-attachments/assets/98cebe82-77ee-4eeb-bbae-93d8f631724d)

- **カーネルモードとユーザーモード**
カーネルは、コンピュータの中心で、メインメモリの管理やCPUのタスクのスケジューリングなど、システムの基本的な操作を行う。この操作が不正に行われれば、セキュリティ上の問題が発生する可能性があるため、カーネルモードとユーザーモードの2つのモードに分けている。

### ユーザーモード
一般のユーザーが使うソフトウェア、アプリケーション、ミドルウェアなどの実行のためのモード。重要なメモリ領域やI/Oデバイスへの直接アクセスが制限されている。
安全に処理できるかを確認した後、必要に応じてカーネルモードに切り替え特権的な操作を行うことができる。

### カーネルモード
OSが直接使用するモードで、特権モードとも呼ばれている。メモリ管理、デバイスドライバの制御、セキュリティの実装など、システム全体の基本的な操作が可能。
アクセス制限がなく、メモリやI/Oデバイスに対する操作が完全に自由で、CPUの全命令も実行することができる。

![kernel-user-mode](https://github.com/user-attachments/assets/623cc929-4116-4530-9c1e-4e31a4e8aa22)

- **シェル**: OSの機能にアクセスするためのインターフェースで、コマンドラインから操作するためのソフトウェアツール。
通常のユーザーがOSの中核部分であるカーネルに直接アクセスすることは危険。そのためシェルが仲介役を果たす。
シェルの背後にはシステムコールという重要な概念が存在する。

![shell](https://github.com/user-attachments/assets/8e1fc627-06fd-4726-b7d2-29796c39509e)

例: `mkdir foo` -> `mkdir()`というシステムコールを使用し、指定された場所に`foo`というディレクトリを作成する。(ユーザー自身がシステムコールを直接扱う必要はない。)

カーネルを取り囲むような外殻の役割を果たすことからシェルという名前に。

# メモリ管理

## メモリ管理

### CPUが直接アクセスできる汎用記憶装置
- **レジスタ**: CPU内部に存在し、数バイト程度の非常に高速な小容量のメモリで、一時的なデータ保持に使用される
- **メインメモリ**: 一般的なPCで数十ギガバイト程度の容量を持ち、現在実行中のプログラムやデータ保持をするために使用される。

複数のプロセスを全てメインメモリに移して実行することは現実的でないため、OSによるメモリ管理が重要。

- **物理アドレス**: コンピュータのメインメモリ内の物理的な配置を指し、それぞれのメモリセルを一意に識別するために使用される。

![physical-address](https://github.com/user-attachments/assets/7d17627f-ef5e-491a-bd3f-eb3a4df686d7)

### メモリの割り当て
- **割り当て**: プロセスがメインメモリを使用するため、空いているメモリに対して予約すること

![memory-allocation](https://github.com/user-attachments/assets/58e1ad4c-f901-4f08-b84b-1e329d846f18)

**割り当てるためのアルゴリズム**  
- First Fit: リスト構造を順に辿り、最初にサイズ n 以上の空きメモリが見つかったホールからメモリを割り当てる
- Worst Fit: 最も大きいホールを割り当てる(リスト構造がサイズ順に並んでいない限り全検索が必要になる可能性がある)
- Best Fit: サイズ n 以上でホールの中から最も小さい領域のホールを割り当てる(リスト構造がサイズ順に並んでいない限り全検索が必要になる可能性がある)
※ **メモリフラグメンテーション**: 連続したメモリ空間の割り当てと解放を繰り返す過程で、小さな領域が多数作られるため、メモリの効率的な使用を妨げ、システムのパフォーマンスに影響を及ぼす可能性がある課題

### スワッピング
- **スワッピング**: プロセスを一時的にメインメモリから、補助記憶装置に相互に移動させることで、メモリの空きを確保すること
  - **メリット**: メインメモリの物理的な容量を超えたプロセスの実行が可能になる
  - **デメリット**: メモリからストレージへの移動には相対的に時間がかかるため、処理速度が遅くなる可能性がある
※ スワップアウト、スワップイン  
![swap-in-out](https://github.com/user-attachments/assets/ec69157c-9454-4dd7-93c1-913d12ad6c97)

## メモリフラグメンテーション
メモリ空間内での割り当てと解放が繰り返されるプロセスで、数多くの小さな領域(ブロック)が生じること  
![memory-fragmentation](https://github.com/user-attachments/assets/b10f3123-c9f1-41b7-b1f2-796bc075539c)

- メモリコンパクション: 点在した空きブロックをかき集めて1つの大きな空き領域を作る手法
![memory-compaction](https://github.com/user-attachments/assets/82b9f0bf-dd09-4f02-a96e-6cb4da10195a)

- ページング: プロセスにとっての仮想アドレスと、物理的なメモリアドレスを分ける手法で、ページテーブルという対応表を用いて両者を関連付ける

## 仮想アドレス
- **仮想アドレス空間**: 各プロセスが占有して扱うことのできるメモリ空間のこと(論理アドレス空間)

他のプロセスが具体的にどこに存在しているのかを気にすることなく、アドレスを指定できる(プロセスが補助記憶装置に移動されたり、物理アドレスが変更されたりすることを考慮する必要がなくなる)  

![virtual-address](https://github.com/user-attachments/assets/b55cc21a-e04c-48b2-83a5-07ab8daeec06)

### MMU
- **MMU**: プロセスが物理メモリ上のどこを使うべきかを管理し、仮想アドレスを対応する物理アドレスに効率的に変換する役割を果たす
           コンピュータのプログラムは、仮想アドレス空間上で実行されるが、実際のデータは物理メモリの中の物理アドレスに保存される。
           この仮想アドレスと物理アドレスの対応関係を管理し、変換するのが主な仕事。
  - 課題
    従来のシステムではアドレス単位で直接的な対応表を使用してMMUが返還を行っていたが、32bit 64bitのシステムでは仮想アドレス空間が非常に大きくなるため対応表もそれに比例して巨大になる。
    32bit -> 43億個の異なるアドレスが存在する。1アドレスあたり4バイトの情報が必要だとするなら、16GBのサイズが必要になる。巨大な対応表をプロセスごとに持つと効率が悪くメモリリソースを大量に消費してしまう。
  - 解決
    ページングの技術。メモリを固定サイズのページと呼ばれる単位に分割し、仮想アドレスと物理アドレスの対応をページ単位で行う。これにより、すべてのアドレスの対応関係を持つ代わりに、使用されているページだけの対応関係を持つことで、対応表のサイズを大幅に削減できる。

![mmu-simple-image](https://github.com/user-attachments/assets/42dc74a1-280c-45eb-9711-0c1a703252cb)

![mmu](https://github.com/user-attachments/assets/1ace45ae-a5e0-478a-a83d-fc9129813f2c)

## ページング
メモリ管理の手法の一つで、プログラムが物理メモリ上に配置される際に、仮想アドレス空間を物理メモリの小さな固定サイズのブロックに分割することを指す。  
この手法により、プログラムが一度に全体が物理メモリ上に配置される必要がなくなり、大きな対応表を使うことなく効率的にメモリを管理することが可能になる。

![what-is-paging](https://github.com/user-attachments/assets/ef4e4c8e-4a8f-4742-b788-d6916c8bc8e3)

- ページ: 仮想メモリを一定のサイズのブロックに分割したもの。通常、ページのサイズは固定されており、4KGなどの標準的なサイズが用いられることが一般的
- フレーム: 物理メモリをページと同じサイズのブロックに分割したもので、実際のメモリにおけるページの格納場所として機能する


![paging-flame](https://github.com/user-attachments/assets/b8657684-24ce-4f86-b8a4-26f644b6c012)







